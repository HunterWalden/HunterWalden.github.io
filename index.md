---
driveId: 1Q5Mek8IZv9vCZ0b_FnVbA-8NURUwOTYe/preview
---

## Self-Assessment

Throughout my time at SNHU, I have learned several important skills in the field of computer science that I will carry with me into my future career. Although I had some coding experience from my own personal research and a year in an on-campus environment, my classes here have introduced me to new languages, concepts, and tactics that I may not have come across otherwise. Some of the most important – and most enjoyable – topics I learned about were code security, SQL, hashing algorithms, and data structures. These areas are also key to a successful career since they are critical to writing industry-standard code. 

Despite working online, my classes have allowed me the opportunity to learn about collaboration. The ability to work in teams is crucial as a programmer, as you are only responsible for one piece of the product – you have to work alongside designers, artists, managers, testers, and other programmers in order to create a polished program. One of my classes was dedicated to learning Git, which is the industry standard for working collaboratively. There is no doubt in my mind that I will be using BitBucket or GitHub for my future projects, so learning how to create branches and safely add new code without causing problems for other team members is critical to my success as a career programmer. I have also had the opportunity to play different roles within a team, giving me a new perspective into how a team can best function. For example, I learned about the difference between a programmer’s mindset (my code works because I wrote it) and a tester’s (this code is broken and I must figure out how). Lastly, I have learned about how to conduct productive peer code reviews by focusing on the code itself rather than attacking the writer and asking why the author has taken a specific approach rather than accusing them of doing it wrong. 

Aside from communicating with team members, I also learned about communicating with stakeholders. One particular class was all about Unified Modeling Language, or UML, and how it is used to design programs before they are written. I was able to create diagrams for a mock program which helped me understand how important it is to lay out a program’s design beforehand – that way you can work out any issues or conflicts as you draw them out rather than as you code them, which would make them significantly harder to fix. Learning about UML is relevant to stakeholders because this is the information they are more likely to see. Diagrams can be extremely helpful since people tend to absorb visual information far better than text. A stakeholder likely does not want a technical overview of the code; they want to see the design plans to ensure they line up with the project requirements. Learning about how these documents are laid out gives me insight on how to communicate properly with stakeholders – I now know to focus on program design and overall functionality rather than details of the actual code. 

I have also learned several critical concepts for writing code. Knowledge of data structures and algorithms is necessary to writing clean and efficient code, and I have been introduced to many different structures and methods at SNHU. Specifically, I had a class that covered binary search trees, vectors, hash tables, and search algorithms. I learned about the speed and complexity of different vector search methods and how they work, how binary trees are set up and when it’s best to use them, and how hash tables can be used to store and access data. Understanding the design and functionality of various data structures allows me to pick and choose which ones to use in different situations, allowing me to tailor my code to take up less space or run more efficiently. These factors are critical when developing a commercial product in order to please the customer and maintain the company’s reputation.

Within my courses, I have been introduced to both SQL and MongoDB database structures. This has allowed me to become familiar with both relational and object-oriented database designs and how to work with them. I learned to execute create, read, update, and delete operations in each language, as well as more complex concepts like aggregation pipelines. These concepts are important because databases are a crucial piece of countless programs, making the probability that I will need to work with them in the future very high. SQL in particular is used in a variety of applications, so learning how to construct and execute queries, as well as learning about security risks like SQL injection, is a critical skill for my career.

Security was one crucial piece of programming that I had very little knowledge of before SNHU. While I learned several concepts throughout my classes, I had an entire course dedicated to secure programming, and it was likely the most important – and my favorite – class that I have taken. This course introduced me to the vulnerabilities related to strings, integers, arrays, pointers, and more. I learned how security flaws can vary from crashing the program to executing arbitrary code through improperly bounded strings. In addition to learning about these threats, I was also taught how to prevent them through bounds checking and other means. These are all critical skills that are absolutely necessary when writing professional software to protect both the client and company’s safety. I feel much more confident in my ability to produce safe code after taking this class. 

I chose one program to improve in all three fields because I wanted to demonstrate my ability to create one clean and properly commented artifact, and I worried I would not be able to accomplish as much polish had I chosen multiple projects. By keeping my focus on the one program I was able to improve its functionality, readability, and real-life application to showcase my skills. The original program was a teaching tool, and as such was not particularly useful, so I used the three areas of interest to turn it into something with a practical application: implementing an SQLite database allows modifications to be saved and retrieved if the program is closed, adding a login system showcases my understanding of protecting data and the importance of password hashing and salting passwords, and reorganizing the classes and ensuring the code is all commented shows my ability to write clean and reusable code. These changes demonstrate the knowledge I have gained throughout my time as a computer science student and speak to my ability to create a documented and functional program.

## Chosen Artifact

This artifact is a C++ project from my Data Structures class back in my third term of 2019. It is a part of a collection of programs I created for my final project, all of which had similar functionality, but used different data types and algorithms. This specific code reads a .csv file full of data on different bids and adds them to a binary search tree. Once the tree is populated, the user can display all the bids, search for a bid, or remove a bid based on the bid ID.

## Code Review

{% include googleDrivePlayer.html id=page.driveId %}

## [Enhancement One: Software Design and Engineering](https://github.com/HunterWalden/HunterWalden.github.io/tree/master/EnhancementOne/BidDatabase) 

I selected this item for several reasons: it had clear room for improvement, it is written in my favorite/most familiar language, and I could find a way to add on to it that would showcase critical skills. Even at first glance the code is very disorganized, so I knew immediately that organizing it into separate class files would be a great way to showcase my ability to create a clean and organized project. Since I have worked with C++ the most, I have more insight into proper procedures such as naming conventions and class structure, making it easier to ensure I follow general coding standards. Lastly, its existing functionality is very limited, so there is plenty of space for improvement. A program that only performs four basic functions and tests their efficiency is not particularly useful outside of a classroom, but it can easily be transformed into a data storage system with a real practical use. 

So far, I have accomplished what I planned to with this enhancement in terms of CS-499-04 in following industry-standard organization and techniques. I have also realized how much security is compromised even with a simple program like this – whenever user input is being read, the program is at risk. Because of this, I have attempted to sanitize any user inputs I read in order to accomplish course outcome CS-499-05.

While I worked on this artifact, I learned how much work it is to refactor code, even a small and simple program like this. I did not expect it to take very long, but I ended up spending several hours testing and modifying it. One of the first challenges I faced was new errors when moving IDEs. This original code was done in Eclipse, but I decided to use Visual Studio since I am more comfortable with it. After creating a new project and pasting the code in, I had to explicitly include new libraries (vector and string) as well as modify my project settings to ensure VS could find the csv parser. Splitting the code into classes was fairly straightforward, but I ran into issues again when working in main(). 

As I said before, I had not realized all the security implications that had to be considered in terms of user input. I often found myself pausing to think through all the potential inputs I had to check for and considering how I would restrict each field. For example, what should the maximum amount of characters for a bid’s title be? How do I ensure a number is entered for the amount? Since I created a new “Add Bid” option, I would have to sanitize every input made when creating a new bid. My biggest struggle was validating that the amount was entered as a number. I could check for non-numeric inputs, but if the user entered a mix of numbers and letters, it could leave characters stuck in the stream. Eventually I decided to read the input as a string, validate it, then convert it to a double. I tried to remain very security-conscious, something I have never really done with a small command-line program like this, and I am very proud of the results so far.

## [Enhancement Two: Algorithms and Data Structure](https://github.com/HunterWalden/HunterWalden.github.io/tree/master/EnhancementTwo/BidDatabase) 

I selected this item for several reasons: it had clear room for improvement, it is written in my favorite/most familiar language, and I could find a way to add on to it that would showcase critical skills. Even at first glance the code is very disorganized, so I knew immediately that organizing it into separate class files would be a great way to showcase my ability to create a clean and organized project. Since I have worked with C++ the most, I have more insight into proper procedures such as naming conventions and class structure, making it easier to ensure I follow general coding standards. Lastly, its existing functionality is very limited, so there is plenty of space for improvement. A program that only performs four basic functions and tests their efficiency is not particularly useful outside of a classroom, but it can easily be transformed into a data storage system with a real practical use. 

So far, I have accomplished what I planned to with this enhancement in terms of CS-499-04 in following industry-standard organization and techniques. I have also realized how much security is compromised even with a simple program like this – whenever user input is being read, the program is at risk. Because of this, I have attempted to sanitize any user inputs I read in order to accomplish course outcome CS-499-05.

While I worked on this artifact, I learned how much work it is to refactor code, even a small and simple program like this. I did not expect it to take very long, but I ended up spending several hours testing and modifying it. One of the first challenges I faced was new errors when moving IDEs. This original code was done in Eclipse, but I decided to use Visual Studio since I am more comfortable with it. After creating a new project and pasting the code in, I had to explicitly include new libraries (vector and string) as well as modify my project settings to ensure VS could find the csv parser. Splitting the code into classes was fairly straightforward, but I ran into issues again when working in main(). 

As I said before, I had not realized all the security implications that had to be considered in terms of user input. I often found myself pausing to think through all the potential inputs I had to check for and considering how I would restrict each field. For example, what should the maximum amount of characters for a bid’s title be? How do I ensure a number is entered for the amount? Since I created a new “Add Bid” option, I would have to sanitize every input made when creating a new bid. My biggest struggle was validating that the amount was entered as a number. I could check for non-numeric inputs, but if the user entered a mix of numbers and letters, it could leave characters stuck in the stream. Eventually I decided to read the input as a string, validate it, then convert it to a double. I tried to remain very security-conscious, something I have never really done with a small command-line program like this, and I am very proud of the results so far.

## [Enhancement Three: Databases](https://github.com/HunterWalden/HunterWalden.github.io/tree/master/EnhancementThree/BidDatabase) 

I selected this item because its current functionality is very restricted. It reads all bids from a .csv file and allows the user to modify the binary tree, but there is no way to write these changes back to the file. This means that any change made is immediately lost when the program exits. I knew I could change this by using a database instead – all changes could be turned into database queries so the data would be stored and accessible if the program is restarted. This was a great opportunity for me to showcase my knowledge of SQL statements by using SQLite, so I decided to take advantage of it.

I have met my goal of CS-499-04 by using SQL, an industry-standard database language, to store and modify bid information. Although SQLite does not follow the typical setup of a server-client, it still showcases my understanding of SQL statements and the C++ framework to execute and retrieve information from them. I also met course outcome CS-499-05 by using prepared statements to sanitize inputs to prevent injection attacks, as well as storing information in my User table as a hash instead of plaintext. 

This assignment was definitely the most difficult of the three, as I have never used SQLite in C++, and my SQL class was quite a while ago. I had to do a lot of outside research on SQLite documentation and tutorials to learn how to execute statements. Luckily, I have worked with SQLite in Java, so I was able to go back and reference that since it has the same basic functions for preparing and stepping into SQL statements. I finished my User database first, and once I had that working, it was fairly easy to create the Bid database using the same structure I had built with modifications.

The next challenge I faced was how to balance the use of both a database and a binary tree. I realized as I began creating my Bid database functions that it might be a bit repetitive to have both database and local storage. However, I also knew it would likely be faster to work with the tree when searching for bids, which would be ideal if I were to turn this into some kind of searching system. After realizing they could work together, I just had to make sure any local changes would be reflected in the database – adding or removing bids from the tree would also have to add or remove them from the table. Additionally, I had to query the database for all the bids once the program was started to add them to the tree.

My last challenge was how to incorporate the .csv file functionality. I did not want to completely remove the ability to utilize .csv files, as adding all bids individually would be unrealistic, so I had to find a way to add any bids read from a file to the database. I found a pretty simple solution by passing a reference to a vector of Bid objects to the function that read in the .csv file. From there, I could just add each new Bid object created from the file contents to the vector, then pass it to the database and add each bid in a single query.
